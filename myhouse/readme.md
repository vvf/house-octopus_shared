## Listener

Слушает все устройства и отправляет полученные от них события в MQTT (почти без обработки).
При старте считывает из БД список устройств и пытается ко всем присоединиться по TCP каналу. Так же запускается периодическая проверка сатуса устройства (просто http запрос корневой страницы). А так же запускается сервер принимающий UPD запросы от устройств.
После того как поступил UPD запрос:
- проверяется есть ли такое устройство в БД и если нет - то добавляется.
- делается запрос статуса, чтобы устросво "понимало" что оно уже обнаружено и больше широковещательные сообщения слать не нужно.
- если в запросе кроме ИД устройства есть что-то, то он интерпретируется как событие и оно отправляется в MQTT
При поступлении сообщения по TCP каналу - оно интерпретируется как событие.
#### формат сообщений от устройств
`<event_name>[:val1][:key=val]` или
`<event_name>:json:<json_string>`
События от устройства отправляются на топик `/house/device/<device_mac>/events/<event_name>`
при этом payload (json) содержит поля
- args - список значений
- kwars - объект ключ-значение
- или совпадает с пришедшим json
## Backend API

Простой вебсверве на flask выдает несколько страниц по шаблону и имеет REST API: `/api/devices`
TODO: перевести API на "Flask-Restless"

## Reactor

Слушает MQTT и реагирует на события в соответствии с правилами в папке rules (собственно это и есть этот модуль)
Все питоновыские файлы в этой папке (модуле) считываются и используются правила которые там есть.
Правила определяются роутером так же как и в flask. в зависмости от названия события в mqtt (название события - как путь к файлу разбито на логические части)
Но правило применяется один раз. Т.е. если под одно и то же событие попадают несколько правил, то будет выполняться только одно из них (вообще надо бы это исправить, но для этого нужно отказаться от использования роутинга фласка).

### reactor_worker.py

Содержит основной класс этой подсистемы, собственно здесь идет сбор правил и их диспечерезация.

### Правила.
#### actions.py

Содержит реакцию на события типа `/house/device/<device_mac>/action/<action_name>`

| `action_name` | payload (json поле) |по умолчанию| описание | например |
|---|---|---|---|---|
|**turn**|||Задает новые значение переключателей на устройстве|
||"state":"on/off/tgl"/0/1 | tgl | новое значение переключателей (вкл/выкл/поменять)| `"state": "on"`
||"relay":[<list>]\{<relay>:<state>}|[]| задает какие переключатели переклчать - тогда массив индексов переключателей, или если это словарь - то ключи - индекс переклчателя - значение новое значение этого переключателя  | `"relay": [0,3]` или `"relay": {0:"on", 3:"off"}`
|**dimm**|state:0-255|128|новое значение - число от 0 до 255|`"state":201`|
||dimmers|[]|то же что и **relay** в **turn**|`"dimm":[0,1]`|
|**sunrise, sunset**|||для устройств типа диммеры: "Восход"/"Закат" - постепенноне изменение от 0 др 255 (или от 255 до 0)||
||dimmers|[]|то же что и **relay** в **turn**|`"dimm":[0,1]`|
||delay|30|задержка между шагами (секунды, не меньше 0.1)|`delay:0.5`|
||time|-|время за которое нужно выполнить "восход"/"закат" (может быть задано **вместо** `delay`|
||step|1|значение на которое меняется диммер за один шаг|
|**ask_status**|(нет)||запросить статус у устройства (ответ придет по /house/device/<device_mac>/events/state||
|**set_info**|name:string, description:string, settings:json||обновить информацию об у устройстве||
|**ping**|(любой)||проверить связь с "reactor"-ом. возвращает по /house/reactor/pong тот же  payload, что получил ||

Так же обработчик `/house/devices/get_list` - опрашивает устройства в БД и высылает по каждому информацию на `/house/device/<device_mac>/events/state`


#### bathroom.py
Обработка событий от устройств в ванной комнате: свет, душевая кабина (вкл/выкл душ)
#### fireplace_room.py
Обработка событий от устройств в комнате с камином: выключатель, свет.
Температура с выключателя ретранслируется в топик `/house/temp/<ИД_термометра>`
#### garage.py
Обработка событий от устройств в гараже: свет вокруг дома, свет в гараже, датчик двидения в гараже (тут правило которое включает лампочку рядом), кнопка в гараже - включает так же первые три лампочки на улице
#### informer.py
транслирует события от имени робота в телеграм хозяину, переводя их в удобный вид.
обрабатывает `house/notify/turn_(on|off)` - подписывает/отписывает от оповещений, payload=`{chat_id:'<ID_чата/пользователя в телеграме>'}`

#### schedule.py

Обарабатывает топики
- `/house/device/<device_mac>/action/schedule/(add|ask|delete)>`
- `/house/device/<device_mac>/action/timer`

|топик (концовка)| payload | default| description|
|---|---|---|---|
|schedule/add|[задача][структура задачи]||Добавляет задачу в рассписание. Поля вреени указывают в какое время будет выполнена задача|
|schedule/ask|-|-|Запрос рассписания для этого устройства.|
|schedule/delete|---|---|Здаляет задачу из рассписания|
|timer|[задача][структура задачи]||поля задачи воспринимаются как прибавление к текущим значниеям времени. Например `{minutes:2, seconds:10}` значит что задача будет выполнена **через** 2 минуты и 10 секунд|

##### структура задачи

|поле|умолчание|описание|
|---|---|---|
is_once|false|"Одноразовая задача" - после выпонения удаляется (используется для задания таймеров)
minutes|null|минуты
hours|null|часы
mday|null|день месяца
month|null|месяц
wday|null|день недели
seconds|null|секунды - **только** для таймера
action|*обязательное поле| строка - значение топика которое добавится к `/house/device/<device_mac>/action/` см [actions.py]
payload|*обязательное поле| строка-JSON - payload для указанного в action топика

 При добавлении задачи поля `minutes`, `hours`, `mday`, `month`, `wday` могут быть либо положительное число, либо равны null (или не заданы совсем), либо отрицательное значение.
 Если такое поле принимает отрицательное значение, то считается что задача должна выполняться раз в это время.

 Например:

 `{ minutes:25, hours: -2}` - будет выполняться в 00:25, 02:25, 04:25, 06:25, и т.д.

##### Рассписние устройства
выдается на топик `/house/device/<device_mac>/schedule`
в payload JSON строка содержащая объект
`{ schedule: [<массив_задач>] }`

#### telegramm.py

Не реализовано (реакция на сообщения из телеграма)

#### watering.py
Обработка событий от устройств полива (с клапанами и кнопками, а так же термометром и гигрометром и фоторезистором):
Пока что таких устройств два.


---
Keenetic - https://gist.github.com/ancientGlider/e72cdaa2daf0af5f8d80f53fea4666be/raw/abfb00e0a2f088a2a65e55884dcd44b12b595eee/keenetic_auth.py
